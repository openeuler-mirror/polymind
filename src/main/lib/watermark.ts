import { nativeImage } from 'electron'
import sharp from 'sharp'

export interface WatermarkOptions {
  isDark?: boolean
  version?: string
  texts?: {
    brand?: string
    time?: string
    tip?: string
    model?: string // Model name
    provider?: string // Provider name
  }
}

/**
 * Create watermark SVG
 * @param width Image width
 * @param options Watermark options
 */
const createWatermarkSvg = (width: number, options: WatermarkOptions): string => {
  const { isDark = false, version = '1.0.0', texts = {} } = options

  const borderHeight = 80
  const yPadding = 40
  const lineHeight = 24

  // Calculate baseline Y coordinate for vertically centered text
  const textBaselineY = borderHeight / 2 + 4
  const upperTextY = textBaselineY - lineHeight / 2 + 4
  const lowerTextY = textBaselineY + lineHeight / 2 + 4

  // Brand identifier and version information
  const brandText = texts.brand || 'DeepChat'
  const versionInfo = 'v' + version

  // Build time information, add model and provider info before timestamp
  const now = new Date()
  const timeStr =
    texts.time ||
    `${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, '0')}/${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`

  // Build complete time line: model info + timestamp
  let timeLineText = ''
  if (texts.model || texts.provider) {
    const modelInfo: string[] = []
    if (texts.provider) {
      modelInfo.push(texts.provider)
    }
    if (texts.model) {
      modelInfo.push(texts.model)
    }
    timeLineText = `${modelInfo.join(' · ')} · ${timeStr}`
  } else {
    timeLineText = timeStr
  }

  const tipText = texts.tip || 'Generated by DeepChat'

  const backgroundColor = isDark ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)'
  const textColor = isDark ? 'rgba(255, 255, 255, 0.9)' : 'rgba(0, 0, 0, 0.9)'
  const lineColor = isDark ? 'rgba(200, 200, 200, 0.5)' : 'rgba(50, 50, 50, 0.5)'

  return `
    <svg width="${width}" height="${borderHeight}" xmlns="http://www.w3.org/2000/svg">
      <!-- Background -->
      <rect width="${width}" height="${borderHeight}" fill="${backgroundColor}"/>

      <!-- Separator line -->
      <rect x="0" y="0" width="${width}" height="1" fill="${lineColor}"/>

      <!-- Time information (left aligned) -->
      <text x="${yPadding}" y="${upperTextY}" font-family="Arial, sans-serif" font-size="16" fill="${textColor}">
        ${timeLineText}
      </text>

      <!-- Tip text (left aligned) -->
      <text x="${yPadding}" y="${lowerTextY}" font-family="Arial, sans-serif" font-size="16" fill="${textColor}">
        ${tipText}
      </text>

      <!-- Brand identifier (right aligned) -->
      <text x="${width - yPadding}" y="${upperTextY}" font-family="Arial, sans-serif" font-size="28" font-weight="bold" text-anchor="end" fill="${textColor}">
        ${brandText}
      </text>

      <!-- Version information (right aligned) -->
      <text x="${width - yPadding}" y="${lowerTextY}" font-family="Arial, sans-serif" font-size="16" text-anchor="end" fill="${textColor}">
        ${versionInfo}
      </text>
    </svg>
  `
}

/**
 * Add watermark to image (main process version)
 * @param imageBuffer Original image buffer
 * @param options Watermark options
 */
export const addWatermarkToImage = async (
  imageBuffer: Buffer,
  options: WatermarkOptions = {}
): Promise<Buffer> => {
  try {
    // Get original image information
    const { width, height } = await sharp(imageBuffer).metadata()

    if (!width || !height) {
      throw new Error('Unable to get image dimensions')
    }

    const borderHeight = 80
    const watermarkSvg = createWatermarkSvg(width, options)
    const watermarkBuffer = Buffer.from(watermarkSvg)

    // Create watermarked image
    const result = await sharp({
      create: {
        width,
        height: height + borderHeight,
        channels: 4,
        background: { r: 0, g: 0, b: 0, alpha: 0 }
      }
    })
      .composite([
        // Original image
        {
          input: imageBuffer,
          top: 0,
          left: 0
        },
        // Watermark
        {
          input: watermarkBuffer,
          top: height,
          left: 0
        }
      ])
      .png()
      .toBuffer()

    return result
  } catch (error) {
    console.error('Error adding watermark:', error)
    // If watermark addition fails, return original image
    return imageBuffer
  }
}

/**
 * Create watermarked image from nativeImage
 * @param image Electron nativeImage object
 * @param options Watermark options
 */
export const addWatermarkToNativeImage = async (
  image: Electron.NativeImage,
  options: WatermarkOptions = {}
): Promise<Electron.NativeImage> => {
  const pngBuffer = image.toPNG()
  const watermarkedBuffer = await addWatermarkToImage(pngBuffer, options)
  return nativeImage.createFromBuffer(watermarkedBuffer)
}
